http://journals.cambridge.org/action/displayAbstract?aid=44197
Subscript and unicode in abstract
@article{Streicher:1998,
  author = {Streicher,Th. and Reus,B.},
  title = {Classical logic, continuation semantics and abstract machines},
  journal = {Journal of Functional Programming},
  volume = {8},
  number = {06},
  pages = {543--572},
  month = nov,
  year = {1998},
  doi = {10.1017/S0956796898003141},
  eprint = {http://journals.cambridge.org/article_S0956796898003141},
  bib_scrape_url = {http://journals.cambridge.org/action/displayAbstract?aid=44197},
  abstract = {One of the goals of this paper is to demonstrate that denotational semantics is useful for operational issues like implementation of functional languages by abstract machines. This is exemplified in a tutorial way by studying the case of extensional untyped call-by-name {\ensuremath{\lambda}}-calculus with Felleisen's control operator [script C]. We derive the transition rules for an abstract machine from a continuation semantics which appears as a generalization of the {\ensuremath{\lnot}}{\ensuremath{\lnot}}-translation known from logic. The resulting abstract machine appears as an extension of Krivine's machine implementing head reduction. Though the result, namely Krivine's machine, is well known our method of deriving it from continuation semantics is new and applicable to other languages (as e.g. call-by-value variants). Further new results are that Scott's {\em D}\ensuremath{_\textrm{[infty infinity]}}-models are all instances of continuation models. Moreover, we extend our continuation semantics to Parigot's {\ensuremath{\lambda}}{\ensuremath{\mu}}-calculus from which we derive an extension of Krivine's machine for {\ensuremath{\lambda}}{\ensuremath{\mu}}-calculus. The relation between continuation semantics and the abstract machines is made precise by proving computational adequacy results employing an elegant method introduced by Pitts.},
}

