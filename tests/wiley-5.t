http://onlinelibrary.wiley.com/doi/10.1002/1097-024X%28200101%2931:1%3C67::AID-SPE357%3E3.0.CO;2-A/abstract
Monospace in title and abstract
@article{Muth:2001:10.1002/1097-024X(200101)31:1<67::AID-SPE357>3.0.CO;2-A,
  author = {Muth, Robert and Debray, Saumya K. and Watterson, Scott and De Bosschere, Koen},
  title = {{\tt alto}: a link-time optimizer for the Compaq Alpha},
  journal = {Software: Practice and Experience},
  volume = {31},
  number = {1},
  pages = {67--101},
  year = {2001},
  publisher = {John Wiley \& Sons, Ltd.},
  issn = {1097-024X},
  doi = {10.1002/1097-024X(200101)31:1<67::AID-SPE357>3.0.CO;2-A},
  bib_scrape_url = {http://onlinelibrary.wiley.com/doi/10.1002/1097-024X%28200101%2931:1%3C67::AID-SPE357%3E3.0.CO;2-A/abstract},
  keywords = {alto, a link-time optimizer, Compaq Alpha},
  abstract = {Traditional optimizing compilers are limited in the scope of their optimizations by the fact that only a single function, or possibly a single module, is available for analysis and optimization. In particular, this means that library routines cannot be optimized to specific calling contexts. Other optimization opportunities, exploiting information not available before link time, such as addresses of variables and the final code layout, are often ignored because linkers are traditionally unsophisticated. A possible solution is to carry out whole-program optimization at link time. This paper describes {\tt alto}, a link-time optimizer for the Compaq Alpha architecture. It is able to realize significant performance improvements even for programs compiled with a good optimizing compiler with a high level of optimization. The resulting code is considerably faster than that obtained using the OM link-time optimizer, even when the latter is used in conjunction with profile-guided and inter-file compile-time optimizations.},
}

